\documentclass[11pt,xcolor=table]{beamer}
\usetheme{CambridgeUS}
\usecolortheme{dolphin}

\usepackage[utf8]{inputenc}
\usepackage[L7x]{fontenc}
\usepackage[lithuanian]{babel}
\usepackage{lmodern} %be neveikia bold, italic etc


\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage{graphicx}
\graphicspath{{./figures/}}

\usepackage{adjustbox}
\usepackage{bm}
\usepackage{subcaption}

\usepackage{multirow} % for multirow tables
\setbeamertemplate{caption}[numbered] % for numbering captions

\usepackage{forest}


\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
	backgroundcolor=\color{lbcolor},
	tabsize=4,
	rulecolor=,
	language=r,
        basicstyle=\scriptsize,
        upquote=true,
        aboveskip={0.5\baselineskip},
        belowskip={0.5\baselineskip},
        columns=fixed,
        showstringspaces=false,
        extendedchars=false,
        breaklines=true,
        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
        frame=single,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        keywordstyle=\color[rgb]{0,0,1},
        commentstyle=\color[rgb]{0.133,0.545,0.133},
        stringstyle=\color[rgb]{0.627,0.126,0.941}
}


\usepackage{tikz, pgfplots}
\usetikzlibrary{patterns,decorations.pathreplacing}


\author{Justas Mundeikis}
\title{Duomenų analizės įvadas}
\subtitle{2-1 Dalis}
%\setbeamercovered{transparent} 
%\setbeamertemplate{navigation symbols}{} 
%\logo{} 
%\institute{Vilniaus Universitetas, EVAF} 
%\date{} 
%\subject{} 


\setbeamerfont{subsection in toc}{size=\scriptsize}
%----------------------------------------------------------
\begin{document}
%----------------------------------------------------------

\begin{frame}
\titlepage
\end{frame}

%----------------------------------------------------------

\begin{frame}{1. Dalies turinys}
\tableofcontents
\end{frame}

%----------------------------------------------------------
\section{R programavimas}
%----------------------------------------------------------
\begin{frame}[fragile]{Šioje dalyje}
2-1 R programavimo dalyje susipažinsime su
\begin{itemize}
\item if-else 
\item for, while, repeat loop
\item R funkcijomis
\item Datos formatais
\end{itemize}
\end{frame}
%----------------------------------------------------------
\subsection{Valdymo struktūros}
%---------------------------------------------------------
\begin{frame}
Valdymo struktūros (control structures) leidžia valdyti programų veikimą, priklausomai nuo tam tikrų aplinkybių:
\begin{itemize}
\item if, else: testuoja tam tikrą aplinkybę
\item for: vykdo programą tam tikrą iteracijų skaičių
\item while: vykdo programą kol egzistuoja tam tikros aplinkybės
\item repeat: vykdo nesibaigiančią iteraciją
\item break: nutraukia iteracijos procesą
\item next: peršoka 1 iteraciją
\item return: nutraukia funkciją
\end{itemize}
\end{frame}

%---------------------------------------------------------
\begin{frame}[fragile]{if}

\begin{lstlisting}
# 1
if(<condition>) {
        ## do something
} 

#2
if(<condition>) {
        ## do something
} else{
        ## do something
}

#3
if(<condition>) {
        ## do something
} else if(<condition>) {
        ## do something
} else{
        ## do something
}
\end{lstlisting}
\end{frame}

%---------------------------------------------------------
\subsubsection{if}
%---------------------------------------------------------

\begin{frame}[fragile]{if}

\begin{lstlisting}
x <- 5

if(x>3){
        y <- 5
} else{
        y <- 0
}

# tapatu

y <- if (x>3) {
        5
} else{
        0
}

\end{lstlisting}
\end{frame}

%---------------------------------------------------------
\subsubsection{for}
%---------------------------------------------------------

\begin{frame}[fragile]{for}
\begin{itemize}
\item for loop dažniausiai naudojami iteruoti tam tikriems veiksmams, žinant, kiek kartų iteracija turi trukti.
\item galima naudoti "i" arba bet kokią kitą raidę / stringą
\end{itemize}
\begin{lstlisting}
for (i in 1:5){
        print(i)
}

for (values in 1:5){
        print(values)
}

[1] 1
[1] 2
[1] 3
[1] 4
[1] 5


\end{lstlisting}
\end{frame}

%---------------------------------------------------------

\begin{frame}[fragile]{for}
\begin{itemize}
\item visi šie for loops veikia vienodai
\end{itemize}
\begin{lstlisting}
x <- c("a", "b", "c", "d", "e", "f")

for (i in 1:6) {
        print(x[i])
}

for (i in seq_along(x)){
        print(x[i])
}

for (raide in x) {
        print(raide)
}

for(i in 1:6) print(x[i])
\end{lstlisting}
\end{frame}

%---------------------------------------------------------

\begin{frame}[fragile]{for}
\begin{itemize}
\item nested for loop
\item retai naudojama, sunkiai suprantama, geriau nekišt nagų 
\end{itemize}
\begin{lstlisting}
for (i in seq_len(nrow(x))) {
        for (j in seq_len(ncol(x))) {
                print(x[i,j])
        }
        
}

seq_len()
\end{lstlisting}
\end{frame}

%----------------------------------------------------------
\subsubsection{while}
%----------------------------------------------------------
\begin{frame}[fragile]{while}
\begin{itemize}
\item while testuoja aplinkybes, jeigu ok, atlieka veiksmą, pabaigus vėl testuoja ir t.t. 
\item while loop gali testis neribotą skaičių iteracijų, tad atsargiai
\item galima sutikti, kai bandoma iteruoti optimizavimo uždavinius, kur while (<condition>) yra siekiama vertė
\end{itemize}
\begin{lstlisting}
count <-0

while(count<5000){
        print(count)
        count <-count+1
}

\end{lstlisting}
\end{frame}

%----------------------------------------------------------
\begin{frame}[fragile]{while}
\begin{itemize}
\item pvz., čia visai neaišku, kada baigsis iteracija
\end{itemize}
\begin{lstlisting}
z<- 5

while(z>=3 && z<=10){
        print(z)
        #rbinom(n, size, prob)
        coin <- rbinom(1,1,0.5)
        if(coin==1){
                z<- z+1
        }else{
                z<- z-1
        }
}

\end{lstlisting}
\end{frame}

%----------------------------------------------------------
\subsubsection{repeat, break, next}
%----------------------------------------------------------
\begin{frame}[fragile]{repeat, break, next}
\begin{itemize}
\item repeat inicializuoja begalinės trukmės loop
\item vienintelis būdas sustabdyti, su break
\item pavojinga funkcija!
\end{itemize}
\begin{lstlisting}
x0 <- 1
tol <- 1e-8

repeat{
        x1 <- computeEstimate() #pvz kokia nors optimizavimo funkcija
        if(abs(x1-x0)<tol){
                break
        }else{
                x0 <-x1
        }
}
\end{lstlisting}
\end{frame}

%----------------------------------------------------------

\begin{frame}[fragile]{repeat, break, next}
\begin{itemize}
\item next komanda peršoka prie sekančios iteracijos
\end{itemize}
\begin{lstlisting}
for (i in 1:100) {
        if(i<=30){
                ## skips the first 30
                next
        }
        print(i)
        
}
\end{lstlisting}
\end{frame}

%----------------------------------------------------------
\subsubsection{}

%----------------------------------------------------------
\begin{frame}[fragile]{R Funkcijos}
\begin{itemize}
\item Užrašome savo pirmą funkciją
\item Ką ji daro?
\end{itemize}
\begin{lstlisting}
add2 <- function(x,y){
        x+y
}

add2(3,5)
\end{lstlisting}
\end{frame}

%----------------------------------------------------------
\begin{frame}[fragile]{R Funkcijos}
\begin{itemize}
\item 2 funkcija
\item Ką ji daro?
\end{itemize}
\begin{lstlisting}
above10 <- function(x){
        use <- x>10
        x[use]
}

c <- seq(1:20)

above10(c)
\end{lstlisting}
\end{frame}

%----------------------------------------------------------

\begin{frame}[fragile]{R Funkcijos}
\begin{itemize}
\item Patobuliname antrą funkciją: 2 argumentai ir antras standartizuotas argumentas
\end{itemize}
\begin{lstlisting}

above <- function(x,y){
        use <- x>y
        x[use]
}
above(c,6)

above <- function(x,y=10){
        use <- x>y
        x[use]
}

above(c)
above(c,2)
\end{lstlisting}
\end{frame}

%----------------------------------------------------------

\begin{frame}[fragile]{R Funkcijos}
\begin{itemize}
\item Funkcija, kuri apskaičiuoja stulpelių vidurkius:
\end{itemize}
\begin{lstlisting}
column_mean <- function(y){
        nc <- ncol(y)
        means <- numeric(nc)
        for (i in 1:nc){
                means[i] <-mean(y[,i])
        }
        means
}

library(datasets)
column_mean(airquality)
\end{lstlisting}
\end{frame}

%----------------------------------------------------------

\begin{frame}[fragile]{R Funkcijos}
\begin{itemize}
\item Kai kurių stulepelių nepavyko apskaičiuoti, nes kai kuriuos reikšmės NA
\item na.rm=TRUE funkcijoje mean(), leidžia apskaičiuoti įverčius pašalinant NA
\end{itemize}
\begin{lstlisting}
column_mean <- function(y){
        nc <- ncol(y)
        means <- numeric(nc)
        for (i in 1:nc){
                means[i] <-mean(y[,i], na.rm = TRUE )
        }
        means
}
\end{lstlisting}
\end{frame}

%----------------------------------------------------------

\begin{frame}[fragile]{R Funkcijos}
\begin{itemize}
\item Funkcijos savaime yra R objektai, kuriuos galima perduoti kaip argumentus kitoms funkcijoms
\item Funkcijos gali būti \textit{nested} viena į kitą
\item Funkcijos rezultatas - paskutinė R išraiška funkcijos viduje
\item \textit{Formal arguments} - predefinuoti argumentai, tai palengvina funkcijų naudojima (pvz., read.csv: sep=",")

\end{itemize}
\begin{lstlisting}
f <- function (<arguments>){
		##  funkcijos veikla
}
\end{lstlisting}
\end{frame}

%----------------------------------------------------------

\begin{frame}[fragile]{R Funkcijos}
\begin{itemize}
\item 

\end{itemize}
\begin{lstlisting}
?sd
sd(x, na.rm = FALSE)

data <- rnorm(100)

sd(data)
sd(x=data)
sd(x=data, na.rm = TRUE)
sd(na.rm = TRUE, x=data)
sd(na.rm = TRUE, data)
\end{lstlisting}
\end{frame}


%----------------------------------------------------------

\begin{frame}[fragile]{R Funkcijos}
\begin{itemize}
\item Pozicinis vs leksinis, dalinis funkcijų argumentų  \textit{matching}
\begin{itemize}
\item Leksikinis pilnas matching
\item Leksikinis dalinis, bet unikalus matching
\item Pozicinis matching
\end{itemize}
\item Patarimas bent jau pradžioje išrašykite argumentus su jų apibrėžimu, padeda greičiau išmokti ir padarysite mažiau klaidų
\end{itemize}
\begin{lstlisting}
args(lm)
function (formula, data, subset, weights, na.action, method = "qr", model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, contrasts = NULL, offset, ...) 

mydata <- data.frame(x=rnorm(1000), y=rnorm(1000))

lm(data=mydata, y~x, model = FALSE, 1:100)
lm(y~x, data=mydata, 1:100, model = FALSE)
lm(y~x, dat=mydata, 1:100, mod = FALSE)
lm (formula= "y~x", data=mydata, subset=1:100,model = FALSE)
plot(lm(formula= "y~x", data=mydata, subset=1:100,model = FALSE))
 
\end{lstlisting}
\end{frame}

%----------------------------------------------------------

\begin{frame}[fragile]{R Funkcijos - Lazy evaluation}
\begin{itemize}
\item \textit{Lazy evaluation} reiškia, jog argumentai funkcijoje panaudojami tada, kai ir jeigu, jų reikia
\end{itemize}
\begin{lstlisting}
f<-function(a,b){
         a^2
}
f(2) #positional matching a=2
[1] 4

f <- function(a,b){
        print(a)
        print(b)
}

f(10)

[1] 10
Error in print(b) : argument "b" is missing, with no default
\end{lstlisting}
\end{frame}

%----------------------------------------------------------

\begin{frame}[fragile]{R Funkcijos - ...}
\begin{itemize}
\item ... indikuoja argmentus, kurie perduodami kitai funkcijai
\item \textit{Generic functions} naudoja ... \textit{methods} (šiuo metu nesvarbu...)
\end{itemize}
\begin{lstlisting}
myplot <- function(x,y,type="l",...){
        plot(x,y,type=type,...)
}

plot(mydata$x, mydata$y)
myplot(mydata$x, mydata$y)
\end{lstlisting}
\end{frame}

%----------------------------------------------------------

\begin{frame}[fragile]{R Funkcijos - ...}
\begin{itemize}
\item ... indikuoja argmentus, kurie perduodami kitai funkcijai
\item \textit{Generic functions} naudoja ... \textit{methods} (šiuo metu nesvarbu...)
\end{itemize}
\begin{lstlisting}
myplot <- function(x,y,type="l",...){
        plot(x,y,type=type,...)
}

plot(mydata$x, mydata$y)
myplot(mydata$x, mydata$y)
\end{lstlisting}
\end{frame}

%----------------------------------------------------------

\begin{frame}[fragile]{R Funkcijos - ...}
\begin{itemize}
\item ...  arba kai funkcija negali žinoti, kokie argumentai bus pateikti, arba kiek jų
\item Tačiau po jų, būtina teisingai išrašyti argumentus

\end{itemize}
\begin{lstlisting}
args(paste)
function (..., sep = " ", collapse = NULL) 

args(cat)
function (..., file = "", sep = " ", fill = FALSE, labels = NULL, 
          append = FALSE) 
paste("a", "b", "c", sep = ",")
[1] "a,b,c"

paste("a", "b", "c", se = ",")
[1] "a b c ,"
\end{lstlisting}
\end{frame}

%----------------------------------------------------------
\subsubsection{Data ir laikas}
%----------------------------------------------------------

\begin{frame}[fragile]{Data ir laikas}
\begin{itemize}
\item Datos turi Date klasę
\item Laikas gali būti POSIXct arba POSIXlt klasės
\item Data išsaugoma kaip dienų skirtumas lyginant su 1970-01-01
\item Laikas išsaugomas kaip sekundžių skirtumas lyginant su 1970-01-01
\end{itemize}
\end{frame}

%----------------------------------------------------------

\begin{frame}[fragile]{Data ir laikas}
\begin{itemize}
\item Character string su data galima paversti į datos klasės objektą
\begin{lstlisting}
x <- as.Date("2019-03-27")

x
[1] "2019-03-27"

class(x)
[1] "Date"

unclass(x)
[1] 17982
\end{lstlisting}
\end{itemize}
\end{frame}

%----------------------------------------------------------

\begin{frame}[fragile]{Data ir laikas}
\begin{itemize}
\item Laikas gali b8ti POSIXct arba POSIXlt klasės
\item POSIXct išsaugo laiką kaip skaičių
\item POSIXlt išsaugo laiką kaip \textit{list} su daug papildomos informacijos
\item Naudingos funkcijos
\begin{itemize}
\item weekdays
\item months
\item quarters
\end{itemize}
\begin{lstlisting}
x <- Sys.time()
x
class(x)
p <- as.POSIXlt(x)
p
unclass(p)
names(unclass(p))
p$sec

unclass(x)

\end{lstlisting}
\end{itemize}
\end{frame}

%----------------------------------------------------------

\begin{frame}[fragile]{Data ir laikas}
\begin{itemize}
\item Komanda strptime padeda iš \textit{charackter string} nuskaityti datą
\item Praktikoje patartina geriau naudotis paketai tokiais kaip \textit{lubridate}, \textit{zoo}
\begin{lstlisting}
datestring <- c("2019 January 21, 21:15","2019 February 14, 14:14")
x <- strptime(datestring, format="%Y %B %d, %H:%M")
x
class(x)

#but not with lithuanian names
datestring <- c("2019 Sausis 21, 21:15","2019 Vasaris 14, 14:14")
x <- strptime(datestring, format="%Y %B %d, %H:%M")
x
\end{lstlisting}
\end{itemize}
\end{frame}

%----------------------------------------------------------

\begin{frame}[fragile]{Data ir laikas}
\begin{itemize}
\item Su datomis galima pasižaisti:
\begin{lstlisting}
x <- as.Date("2019-03-27")
class(x)

y <- strptime("2019 January 21, 21:15", format="%Y %B %d, %H:%M")

x-y

as.POSIXct(x)-y
as.POSIXlt(x)-y

\end{lstlisting}
\end{itemize}
\end{frame}

%----------------------------------------------------------

\begin{frame}[fragile]{Data ir laikas}
\begin{itemize}
\item Su datomis galima pasižaisti:
\begin{lstlisting}
x <- as.Date("2016-02-28"); y <- as.Date("2016-03-01")
y-x
x <- as.Date("2016-02-28"); y <- as.Date("2016-02-29")
y-x

lt <- as.POSIXct("2019-02-27 08:00:00", tz = "EET")
us <- as.POSIXct("2019-02-27 08:00:00", tz = "EST")
us-lt
\end{lstlisting}
\end{itemize}
\end{frame}





%----------------------------------------------------------
\section{Tvarkingas kodavimas}

\begin{frame}{Tvarkingas kodavimas}
\begin{itemize}
\item Visada rašykite kodą su (plain text) editoriumi
\item Naudokite \textit{identing} (8 spaces) (CRTL+I @R)
\item Max eilučių ilgis: 80 ženklų
\item Apribokite funkcijas: 1 funkcija - 1 operacija
\end{itemize}
\end{frame}

\end{document}