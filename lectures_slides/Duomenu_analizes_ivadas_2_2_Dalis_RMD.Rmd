---
title: "Duomenų analizės įvadas"
subtitle: '2.2. dalis - R programavimas'
author: "Justas Mundeikis"
institute: "VU EVAF"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
 beamer_presentation:
  includes:
   in_header: header.txt
---

```{r setup, include=FALSE, error=TRUE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE)
library(kableExtra)
```

## Turinys
\tableofcontents

# Loop funkcijos

## Loop funkcijos
Rašant skriptus, `for`, `while` ir kiti loopai yra tinkami, bet jeigu norima parašyti kodą tiesiog konsolėje, tada susiduriama su daug problemų.

* `lapply`: loopina per list ir paleidžia funkciją kiekvienam elementui
* `sapply`: kaip ir `lapply` tik supaprastina rezultatus
* `apply`: taiko funkciją masyvo stulepliams / eilutėms
* `tapply`: taiko funkciją vektoriaus dalims
* `mapply`: multivariatinė `lapply` versija 

# lapply
## lapply
`lapply` priima 3 argumentus: (1) list objektą, (2) funkciją arba funkcijos pavadinimą, (3) galimus funkcijos papidlomus argumentus

Jeigu `X` nėra list, tada R bando paversti `X` list objektu.
```{r}
args(lapply)
lapply
```

## lapply
`lapply` visad grąžina `list` klasės objektą
```{r}
x <-  list(a=1:10, b=rnorm(10), c=seq(from=100, to=200, by=2))
lapply(x, mean)
```

## lapply
```{r}
x <- 1:3
as.list(1:3) #taip lapply mato vektorių x konvertvus jį į list objektą
lapply(x, runif)
```

## lapply
Išnaudojant `...` galime perleisti papildomus argumentus `runif` funckijai:
```{r}
x <- 1:3
lapply(x, runif, min=5, max=10)
```

## lapply
`lapply` ir kitos apply funkcijos gali naudotis anoniminėmis funkcijomis, t.y. niekur kitur nedefinuotomis funkcijomis

```{r}
x <- list(a=matrix(1:9, nrow=3, ncol = 3), 
          b=matrix(1:4, nrow = 2, ncol=2))
lapply(x, function(elt) elt[,1, drop=FALSE]) #elt yra anoniminė funkcija
```

# sapply
## sapply
`sapply` bando supaprastinti `lapply` rezultatus (jeigu įmanoma)

* jeigu `lapply` grąžintų list, kurių kiekvienas elementas yra 1 ilgumo, tada `sapply` grąžina vektorių
* jeigu `lapply` grąžintų list, kurių kiekvienas elementas yra >1 ir vienodo ilgumo, tada `sapply` grąžina matricą
* jeigu netinka pirma du variantai, grąžina list

## sapply
```{r}
x <-  list(a=1:10, b=rnorm(10), c=seq(from=100, to=200, by=2))
lapply(x, mean)
```

## sapply
```{r}
x <-  list(a=1:10, b=rnorm(10), c=seq(from=100, to=200, by=2))
sapply(x, mean)
```

# apply
## apply
`apply` naudojama taikyti funkcijas dataframe, matricų eilutėms ar stulpeliams. `apply` iš esmės supaprastina `for loop` naudojimą.

```{r}
str(apply)
```

## apply
```{r}
x <- matrix(1:4,2,2)
x
apply(x, 1, mean) #1 - eiltuėms
apply(x, 2, mean) #2 - stulpeliams
apply(x, 1, sum)
apply(x, 2, sum)

```


## apply
Jeigu norima apskaičiuoti dataframe / matricų eilučių ar stuleplių sumas / vidurkius, galima naudoti jau supaprastintas funckijas, jos veikia dar greičiau, nei originalas.

* `rowSums=apply(x,1,sum)`
* `rowMeans=apply(x,1,mean)`
* `colSums=apply(x,2,sum)`
* `colMeans=apply(x,2,mean)`

## apply

```{r}
x <- matrix(rnorm(20),5,4)
apply(x, 1, quantile, probs=c(0.25 ,0.5, 0.75))

```

## apply
Norint pritaikyti apply funkciją daugiau dimensijų turinčiam duomenų masyvui, būtina nurodyti vektorių, kurios dimensijos išlaikomos
```{r}
x <- array(data=rnorm(40), dim = c(2,2,10))
apply(x, c(1,2), mean)
```

# mapply
## mapply
`mapply` taiko paraleliai (vienu metu) funckiją skirtingiems argumentams
```{r}
str(mapply)
```

* `FUN` yra funkcija, kuri bus taikoma
* `...` argumentai, kuriais naudojamasi funkcijoje
* `MoreArgs` kiti `FUN` argumentai
* `SIMPLIFY` ar rezultatas turėtų būti simplifikuotas kaip `sapply`

## mapply
Jeigu norime sukurti tokį list objektą, 4 kartus rašome rep(), su argumentais 1-4 ir 4-1
```{r}
list(rep(1,4), rep(2,3), rep(3,2), rep(4,1))
```


## mapply
Supaprastinant galima naudoti `mapply` funkciją, kurios argumentai `rep` funckija ir du vektoriai 1:4 ir 4:1
```{r}
mapply(rep, 1:4, 4:1)
```

## mapply
Funkcija `noise` generuoja `n` atsitiktinių normaliojo skirstinio skaičių su vidurkiu `mean` ir standaritiniu nuokyrpiu `sd`
```{r}
noise <- function(n, mean, sd){
        rnorm(n, mean, sd)
}

noise(4,1,2) # veikia kaip tikėtasi
# list(noise(1,1,0.1),noise(2,2,0.1),noise(3,3,0.1),noise(4,4,0.1))
noise(1:4,1:4,0.01) # veikia ne kaip tikėtasi
```

## mapply
Šioje vietoje galima naudotis `mapply` tam kad funkcija primtų argumentus iš vektorių
```{r}
noise <- function(n, mean, sd){
        rnorm(n, mean, sd)
}
# list(noise(1,1,0.1),noise(2,2,0.1),noise(3,3,0.1),noise(4,4,0.1))
mapply(noise, 1:4, 1:4, 0.1)
```

# tapply
## tapply
Apply a function to each cell of a ragged array, that is to each (non-empty) group of values given by a unique combination of the levels of certain factors.

```{r}
str(tapply)
```

* `X` yra vektorius
* `INDEX` faktorius arba faktorių list
* `FUN` taikoma funkcija
* `...` papildomi `FUN` argumentai
* `simplify` ar supaprastinti rezultatus


## tapply
```{r}
x <- c(rnorm(10), runif(10), rnorm(10,1))
x
# Generate factors by specifying the pattern of their levels.
#gl(n, k, length = n*k, labels = seq_len(n), ordered = FALSE)
f <- gl(3,10) 
f
tapply(x, f, mean)
```
## tapply
```{r}
tapply(x, f, mean, simplify = FALSE)
```

## tapply
```{r}
tapply(x, f, summary)
```

# split

## split
`split` padalina vektorių arba kitą objektą į grupes priklausomai nuo faktorių arba faktorių list
```{r}
str(split)
```

* `x` vektorius / list / dataframe
* `f` faktorius arba faktorių list
* `drop` indikuoja, ar tušti faktoriai turėtų būti panaikinti 


## split
```{r}
split(x, f)
# dabar galima naudoti lapply / sapply
```

## split
Taigi galime suskaidyti `x` į 3 `list` objektus ir tada kiekvienam atlikti `lapply` arba
```{r}
lapply(split(x, f),mean)
tapply(x, f, mean)
```

## split
```{r}
head(airquality)
```

## split
```{r}
s <- split(airquality, airquality$Month)
lapply(s, function(x) colMeans(x[,1:4]))
```

## split
```{r}
s <- split(airquality, airquality$Month)
lapply(s, function(x) colMeans(x[,1:4], na.rm=TRUE))
```

## split
```{r}
s <- split(airquality, airquality$Month)
sapply(s, function(x) colMeans(x[,1:4], na.rm=TRUE))
```

## split
```{r}
regionas <- as.factor(rep(c("Vilnius", "Kaunas", "Klaidpėda"), each=10 ))
lytis <- as.factor(c("M", "V"))
x <- data.frame(metai=rep(2013:2017),
                regionas=rep(c("Vilnius", "Kaunas", "Klaidpėda"), each=10 ),
                lytis=c("M", "V"),
                bvp=rep(runif(5,100,200),3),
                vartojimas=rnorm(30)
                )
s <- split(x, list(regionas, lytis))
```

## split
```{r}
head(x,15)
```

## split
```{r}
head(s,2)

```

## split
```{r}
sapply(s, function(x) mean(x[,4]))
sapply(s, function(x) colMeans(x[,4:5]))
```


# Distribucijos

## Distribucijos
Ne retai atliekant įvarius tyrimus ar skaičiuojant tikimybes statistikoje, reikės remtis tam tikrais skirstiniais.
R gali generuoti įvarius skirstinius (*distributions*) 
`?distributions`

* dnorm
* dgamma
* beta
* dpois

ir t.t.

## Distribucijos
Šioje dalyje aptarsime

* Binomial Distribution
* Poisson Distribution
* Continuous Uniform Distribution
* Exponential Distribution
* Normal Distribution


## Distribucijos
Visos distribucijos galimos su 4 funkcijomis:

```{r, eval=FALSE}
# ?dnorm

dnorm(x, mean = 0, sd = 1, log = FALSE)
pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)
qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)
rnorm(n, mean = 0, sd = 1)

```

* d density
* p cumulative distribution
* q quantile function
* r random number generation

## set.seed(...)
Tyrimuose naudojant sugeneruotus atsitiktinius skaičius iš tam tikro skirstinio, būtina naudoti 
`set.seed()`, tam, kad tyrimas būtų atkartojamas.
```{r}
set.seed(1)
rnorm(n=5, mean=5, sd=2)
rnorm(n=5, mean=5, sd=2)
set.seed(1)
rnorm(n=5, mean=5, sd=2)
```

#  Binominis skirstinys
## Binominis skirstinys
Dichotomine matavimų skale matuojamų požymių reikšmių skirstinys. Skirstinys yra diskretus ir apibūdinamas parametrais *n* ir *p*. Parametras $n \geq 0$ reiškia bandymų skaičių, o *p* – požymio tikimybę įgyti vieną iš dviejų galimų reikšmių. 

Binominio skirstinio pasiskirstymo tankio funkcija (tikimybė gauti x reikmšę su n bandymų ir p tikimybės reikmše):
$$ f(x)= \binom{n}{x} p ^x (1-p)^{n-x} \text{ kur } x=1,2,3,...,n$$


## Binominis skirstinys
Tarkime duomenų analizės teste yra 10 klausimų, kurių kiekvienas turi 4 galimus atsakymus, iš kurių tik vienas yra teisingas. Tarkime studentas atėjo visiškai nepasiruošęs ir visiškai atsitiktinai pasirinks atsakymus. Norint išlaikyti testą, reikia teisingai astakyti į ne mažiau kaip 5 klausimus.
Kokia tikimybė, jog studentas neišlaikys testo?

* p = 1/4=0.25 ir (1-p)=1-0.25=0.75
* n = 10
* x=4

## Binominis skirstinys

* p = 1/4=0.25 ir (1-p)=1-0.25=0.75
* n = 10
* x=4

```{r}
# tikimybė jog studentas atsakys lygiai 4 teisingai
dbinom(x=4, size = 10, prob = 0.25)
```

## Binominis skirstinys

```{r, fig.height=5}
x <- seq(from=0, to=10, by=1)
y <- dbinom(x, size=10, prob=0.25)
plot(x,y, type = "p")
axis(side = 1, at = x,labels = T)
```

## Binominis skirstinys
Tačiau norint žinoti visas vertes iki 4
```{r}
# todėl norint žinoti tikimybę jog studentas atsakys į 4 arba mažiau
dbinom(x=0, size = 10, prob = 0.25)+
        dbinom(x=1, size = 10, prob = 0.25)+
        dbinom(x=2, size = 10, prob = 0.25)+
        dbinom(x=3, size = 10, prob = 0.25)+
        dbinom(x=4, size = 10, prob = 0.25)

# alternatyviai galima pasinaudoti pbinom()
pbinom(q=4, size= 10, prob = 0.25, lower.tail = TRUE)
# tačiau piktąjį dėstytoją domina, 
# kokia tikimybė, jog studentas "praslys":
pbinom(q=4, size= 10, prob = 0.25, lower.tail = FALSE)
```

## Binominis skirstinys

```{r, fig.height=5}
x <- seq(from=0, to=10, by=1)
y <- pbinom(x, size=10, prob=0.25)
plot(x,y, type = "p")
axis(side = 1, at = x,labels = T)
```


## Binominis skirstinys
Tarkime dėstytojas nori nustatyti ribą, į kiek klausimų turi teisingai atsakyti studentai, kai:

* studentai turėdami 4 galimus pasirinkimus (daugiau alternatyvių atsakymų dėstytojas nenori sugalvoti, nes tingi)
* destyjas nenori, kad studentai praslystų pro testą didesne nei 10% tikimybe
* destytojas tingi galvoti daugiau nei 10 klausimų

```{r}
qbinom(0.1, 10, 0.25, lower.tail = FALSE)
```

## Binominis skirstinys

```{r, fig.height=5}
x <- seq(from=0, to=10, by=1)
y <- pbinom(x, size=10, prob=0.25)
plot(x,y, type = "p")
axis(side = 1, at = x,labels = T)
```

# Poisson skirstinys

## Poisson skirstinys
Dichotomine matavimų skale matuojamų požymių reikšmių skirstinys. Skirstinys yra diskretus ir apibūdinamas parametrais *n* ir *p*. Parametras $n \geq 0$ reiškia bandymų skaičių, o *p* – požymio tikimybę įgyti vieną iš dviejų galimų reikšmių. 

Poisson skirstinio pasiskirstymo tankio funkcija:
$$ f(x)= \frac{\lambda^x e^{-\lambda}}{x!} \text{ kur } x=1,2,3,...,n$$


## Poisson skirstinys
Poisson distribucija
```{r, eval=FALSE}
# ?dpois

dpois(x, lambda, log = FALSE)
ppois(q, lambda, lower.tail = TRUE, log.p = FALSE)
qpois(p, lambda, lower.tail = TRUE, log.p = FALSE)
rpois(n, lambda)
```

## Poisson skirstinys

Poisson distribucija, kur $\lambda$ yra vidutinė įvykio tikimybė per tam tikrą laikotarpį
```{r, fig.height=3}
rpois(n=10, lambda = 1)
rpois(n=10, lambda=2)
hist(rpois(n=1000, lambda=2))
```


## Poisson skirstinys

Skambučių centras per valandą sulaukia 50 skambučių. *Maximum capacity* yra 65 skambučiai per valandą. Tada skambučiai nukreipiami į alternatyvų skambučių centrą, kuriame dirba beždžionėlės, tad klientai visad lieka nepatenkinti. Klausimas, kokia yra tikimybė, jog per sekančią valandą skambučių centras sulauks: 5, 30, 60  (arba mažiau skambučių):
```{r}
dpois(5, 50) ## 5 Pr(x=5), lambda=50
dpois(30 , 50) ## 30  Pr(x=30), lambda=50
dpois(60, 50) ## 60  Pr(x=50), lambda=50

ppois(5, 50) ## 5 arba mažiau skambučių Pr(x<=5), lambda=50
ppois(30, 50) ## 30 arba mažiau skambučių Pr(x<=30), lambda=50
ppois(60, 50) ## 60 arba mažiau skambučių Pr(x<=50),lambda=50
```


## Poisson skirstinys

Kokia tikimybė, jog skambučių centras sulauks daugiau skaimbučių nei  skabučių centro maksimalus aptarnavimo limitas?
Jeigu įmonės išsikeltas tiklsas, jog nepatenkintų klientų būtų mažiau nei 0.1%, ar patartumėte vadovybei plėsti skambučių centro galimybes? Kiek papildomų darbuotojų reikia nusamdyti skambučiui centrui, jeigu 1 darbuotojas gali priimti po 5 skambučius per valandą?

```{r}
ppois(q=65, lambda = 50, lower.tail = TRUE)
ppois(q=65, lambda = 50, lower.tail = FALSE)

# Kiek papildomų skambučių reiktų papildomai galėti priimti?
qpois(p=0.001, lambda = 50, lower.tail = FALSE)
ceiling(
        (qpois(p=0.001, lambda = 50, lower.tail = FALSE) - 65) / 5
        )
```

# Tolygusis skirstinys (Continuous uniform distribution)
## Tolygusis skirstinys (Continuous uniform distribution)
Skirstinys su vienoda tikimybe visiems skaičiams tarp `a` ir `b`. Visais kitais atvejais tikimybė =0.
$$
f(x)=
\begin{cases} 
\frac{1}{b-a} \text{ when } a \leq x \leq b
\\0, else
\end{cases}
$$

## Tolygusis skirstinys (Continuous uniform distribution)

```{r, fig.height=5}
dist <- runif(n=1000, min=2, max=5)
hist(dist, breaks = seq(from=0, to=6, by=1))
```

# Eksponentinis skirstinys
## Eksponentinis skirstinys
$$
f(x, \lambda)=
\begin{cases} 
\lambda e^{- \lambda x} , \text{ when }x\geq 0
\\0, x < 0
\end{cases}
$$

$$
f(x, \mu)=
\begin{cases} 
\frac{1}{\mu} e^{-x/ \mu} , \text{ when }x\geq 0
\\0, x < 0
\end{cases}
$$


## Eksponentinis skirstinys
PVZ: Tarkime kasininkas aptarnauja vieną klientą per vidutiniškai 3 minutes. Žinoma, kad aptarnavimo laikas turi eksponentinį skirstinį. Kokia tikimybe sekantis klientas bus aptarnautas per mažiau nei 2 minutes

* vidutinis aptarnavimo greitis: 1/3=0.333 klientų per minutę

```{r}
pexp(2, rate=1/3)
```

## Eksponentinis skirstinys
```{r, fig.height=5}
x <- seq(from=0, to=10, by=1)
y <- dexp(x, rate=1/3 )
plot(x,y, type = "p")
axis(side = 1, at = x,labels = T)
```

## Eksponentinis skirstinys
```{r, fig.height=5}
x <- seq(from=0, to=10, by=1)
y <- pexp(x, rate=1/3 )
plot(x,y, type = "p")
axis(side = 1, at = x,labels = T)
```

# Normalusis skirstinys
## Normalusis skirstinys

Sakysime, kad atsitiktinis dydis x turi normalųjį skirstinį, jei jo tankis
$$\varphi_{\mu,\sigma}(x)=\frac{1}{\sqrt{2 \pi \sigma^2}}e^{-(x-\mu)^2/(2\sigma^2)} \text{ for } - \infty<x< \infty ; -\infty<\mu< \infty, \sigma^2>0 $$
Sakysime, kad atsitiktinis dydis x turi standartinį normalųjį skirstinį, jeigu $\mu=0, \sigma^2=1$

## Normalusis skirstinys
```{r, fig.height=5}
x <- seq(from=-5, to=5, by=0.2)
y <- dnorm(x)
plot(x,y, type = "p")
axis(side = 1, at = x,labels = F)
```

## Normalusis skirstinys
```{r, fig.height=5}
x <- seq(from=-5, to=5, by=0.2)
y <- pnorm(x)
plot(x,y, type = "p")
axis(side = 1, at = x,labels = F)
```